{% extends "base.html" %}
{% load staticfiles %}

{% block content %}

<html>
<div class="jumbotron text-center">
  <div class="container">

    <h1>VIEW</h1>
    <p>Blind Spot Calculator for Large Trucks</p>
  </div>
</div>
<div class="container">

  <h3>
<div id="instructiontxt">Choose field of view image to upload</div></h3>
    <br>
<div id="steps" class="hidden">
<div id="canvas">Click to draw<br/></div>
<div id="dataentry" class="hidden">
<form>
  <div class="form-group">
    <label for="h">Driver eye heigh above ground in inches:</label>
    <input type="text" class="form-control" id="dh" placeholder="Enter height eg: 63">
    <small id="radiusdescript" class="form-text text-muted">Measurement 'A' on worksheet.</small>
  </div>
  <div class="form-group">
    <label for="r">Radial distance from driver to measurement stick in inches:</label>
    <input type="text" class="form-control" id="rd" placeholder="Enter distance eg: 94">
    <small id="radiusdescript" class="form-text text-muted">Measurement 'C' on worksheet. This is not the hypotenuse, but the distance along the ground.</small>
  </div>
  <div class="form-group">
    <label for="c">Distance from drivers's eye/camera to passenger window in inches:</label>
    <input type="text" class="form-control" id="c" placeholder="Enter distance eg: 45">
    <small id="radiusdescript" class="form-text text-muted">Measurement 'B' on worksheet.</small>
  </div>
  <div class="form-group">
    <label for="d">Distance from driver's eye/camera to front bumper of truck in inches:</label>
    <input type="text" class="form-control" id="d" placeholder="Enter distance eg: 84">
    <small id="radiusdescript" class="form-text text-muted">Measurement 'D' on worksheet.</small>
  </div>

</form>
<hr>
</div>

<h3>
<div id="percentage">

</div>
</h3>

<div id="vinentry" class="hidden">
<form>
  <div class="form-group">
    <label for="vin">VIN number:</label>
    <input type="text" class="form-control" id="vvin" placeholder="Eg: 1C3CCBBGXCN287756">
  </div>
</form>
</div>

<button class="btn btn-primary" onclick="clearPanel()">Clear</button>
<button class="btn btn-primary" onclick="nextPanel()">Next</button>
<hr>
</div>

 <input type="file" onchange="previewFile()"><br>
 <img src="" height="0" alt="">

<hr>

  <div class="row">
    <div class="col-md-6">
      <h3><span class="glyphicon glyphicon-info-sign"></span> Instructions</h3>
      <ul>
        <li> The image you upload will look warped, that's okay </li>
        <li> You may want to consider cropping your image if the windows do not make up the majority of the photo </li>
        <li> Try to be as accurate as possible </li>
        <li> You will need the four measurements shown here: </li>
        <img src="static/marks.jpg" width="1000">
        <li> The scanning instructions can be found here: TODO</li>
        <li> Please watch our video walkthrough of how to add a truck if you have not added one before: </li>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/IYucUl6kP3w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
      </ul>
    </div>
  </div>
  
</div>
</html>

<script type="text/javascript">
function clearPanel() {
    ctx.addBack(my_image);
}

function nextPanel() {
    ctx.addNext(my_image);
}

var color_marks = [];
var curr_step = 1;
var bottom_view_front = [];
var bottom_view_passenger = [];
var height_map = {};
var neg_90;
var zero;
var angle_map = {};
var driver_height
var marks_dist; 
var c;
var d;
var total_volume;
var blind_volume = 0;
var perc;

function c(img) {
    // Creates a new canvas element and appends it as a child
    // to the parent element, and returns the reference to
    // the newly created canvas element

    function createCanvas(parent, width, height) {
        var canvas = {};
        canvas.node = document.createElement("canvas");
        canvas.context = canvas.node.getContext("2d");
        canvas.node.width = width || 100;
        canvas.node.height = height || 100;

        parent.appendChild(canvas.node);

        return canvas;
    }

    function storeCoordinate(xVal, yVal, array) {
        array.push({x: xVal, y: yVal});
    }

    function storeOneCord(oVal, array){
        array.push(oVal);
    }

    function getAverage(array){
        var sum = 0;
        for( var i = 0; i < array.length; i++ ){
            sum += parseInt( array[i], 10 ); //don't forget to add the base
        }
        var avg = sum/array.length;
        avg = Math.round(avg);
        return avg;
    }

    function init(container, width, height, fillColor) {
        var canvas = createCanvas(container, width, height);
        var coords = [];
        ctx = canvas.context;

        // define a custom fillCircle method
        ctx.fillCircle = function(x, y, radius, fillColor) {
            this.fillStyle = fillColor;
            this.beginPath();
            this.moveTo(x, y);
            this.arc(x, y, radius, 0, Math.PI * 2, false);
            this.fill();
        };

        ctx.addBack = function (img){
          var image = new Image()
          image.onload = function () {
                coords = [];
            ctx.drawImage(image, 0, 0, width, height);
          }
          image.src = img
        }
        ctx.addBack(img);

        /*
            step instruction block, controls flow of user entered info
            data collected in each step is stored in the next because this is what happens after the
            user clicks next on that step
        */
        ctx.addNext = function (img){
            var image = new Image()
            image.onload = function () {
                if (curr_step <= 6) { // right now we are accepting marks up to 6 feet 
                    var avg = getAverage(coords);
                    color_marks.push(avg);
                    coords = [];
                    instructiontxt.innerHTML = "If " + curr_step + " foot mark is visible use click to draw small horizontal line on mark, when done click next. If not visible, click next. Press clear if errors are made.";
                    curr_step += 1;
                } else if (curr_step == 7) {
                    var avg = getAverage(coords);
                    color_marks.push(avg); // save color marks representing feet
                    coords = [];
                    instructiontxt.innerHTML = "Draw vertical line at 0 degrees (directly in front of the driver, should be where the measuring stick was placed).";
                    curr_step += 1;
                } else if (curr_step == 8){
                    var avg = getAverage(coords);
                    zero = avg; // save zero degree point
                    coords = [];
                    instructiontxt.innerHTML = "Draw vertical line at -90 degrees (directly to the right of the driver out of passenger window).";
                    curr_step += 1;
                } else if (curr_step == 9) {
                    var avg = getAverage(coords);
                    neg_90 = avg; // save negative 90 degree point
                    coords = [];
                    instructiontxt.innerHTML = "Draw line along bottom of front field of view.";
                    curr_step += 1
                } else if (curr_step == 10) {
                    bottom_view_front = coords;
                    instructiontxt.innerHTML = "Draw line along bottom of passenger side field of view.";
                    coords = [];
                    curr_step += 1;
                } else if (curr_step == 11) {
                    bottom_view_passenger = coords;
                    var item = document.getElementById('dataentry');
                    if (item) {
                      if(item.className =='hidden'){
                        item.className = 'unhidden';
                      }
                    }
                    instructiontxt.innerHTML = "Enter the driver height and distance from driver to measurement stick";
                    curr_step += 1;
                } else if (curr_step == 12) {
                    driver_height = Math.round(document.getElementById('dh').value, 0);
                    marks_dist = Math.round(document.getElementById('rd').value, 0);
                    c = Math.round(document.getElementById("c").value, 0);
                    d = Math.round(document.getElementById("d").value, 0);
                    createHeightMap();
                    calcGroundIntersection();
                    var item = document.getElementById('dataentry');
                    if (item) {
                      if(item.className =='unhidden'){
                        item.className = 'hidden';
                      }
                    }
                    var item = document.getElementById('vinentry');
                    if (item) {
                      if(item.className =='hidden'){
                        item.className = 'unhidden';
                      }
                    }
                    instructiontxt.innerHTML = "To add to the database for others to use please enter VIN number";
                    curr_step += 1;   
                } else { // optional vin step
                    var vin = document.getElementById('vvin').value;
                    truckInfoFromVIN(vin, perc);
                    instructiontxt.innerHTML = "Truck added to database, you can access the database on the get existing truck info page";
                    var item = document.getElementById('vinentry');
                    if (item) {
                      if(item.className =='unhidden'){
                        item.className = 'hidden';
                      }
                    }

                }
                ctx.drawImage(image, 0, 0, width, height);
            }
            image.src = img;
        }
        ctx.addNext(img);

        // bind mouse events
        canvas.node.onmousemove = function(e) {
            if (!canvas.isDrawing) {
               return;
            }
            var x = e.pageX - this.offsetLeft;
            var y = e.pageY - this.offsetTop;
            var threshold = 5;
            if(y > height - threshold || x > width - threshold || x < threshold || y< threshold ){
                canvas.isDrawing = false;
            }
            var radius = 3; // or whatever
            var fillColor = '#ff0000';
            if (curr_step <= 7) {
                storeOneCord(y, coords);
            } else if (curr_step <= 9) {
                storeOneCord(x, coords);
            } else {
                storeCoordinate(x, y, coords);
            }
            ctx.fillCircle(x, y, radius, fillColor);
        };
        canvas.node.onmousedown = function(e) {
            canvas.isDrawing = true;
            console.log(canvas);
        };
        canvas.node.onmouseup = function(e) {
            canvas.isDrawing = false;
        };
    }

    var container = document.getElementById('canvas');
    var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
    if(width < 1200) width = 1200;

    init(container, width*.75, width*.4, '#ddd', img);
};

/*
previewFile displays the truck image
*/
function previewFile() {
    // Where you will display your image
    var item = document.getElementById('steps');
    if (item) {
      if(item.className =='hidden'){
        item.className = 'unhidden';
      }
    }
    var preview = document.querySelector('img');
    // The button where the user chooses the local image to display
    var file = document.querySelector('input[type=file]').files[0];
    // FileReader instance
    var reader  = new FileReader();

    // When the image is loaded we will set it as source of
    // our img tag
    reader.onloadend = function () {
      preview.src = reader.result;
      my_image = preview.src;
    c(preview.src);
    }
    
    if (file) {
      // Load image as a base64 encoded URI
      reader.readAsDataURL(file);

    } else {
      preview.src = "";
    }
}

/*
createHeightMap creates a hashmap mapping pixel locations on the image to the height they
correspond with at the radial distance the measurment stick is at

*/
function createHeightMap(){
    for (var i = 0; i < color_marks.length; i++){
        if (color_marks[i] & color_marks[i+1]){
            var diff = color_marks[i] - color_marks[i+1];
            var increment = 12 / diff;
            var inches_val = i * 12;
            for (var j = color_marks[i]; j >= color_marks[i+1]; j--){
                height_map[j] = inches_val;
                inches_val += increment;
            }

        } else if (color_marks[i+1] & color_marks[i+2]){ // beginning of list
            var diff = color_marks[i+1] - color_marks[i+2];
            var increment = 12 / diff;
            var inches_val = (i-9) * 12; // needed at the begining not the end because we increment up
            // we extend downward to handle all trucks
            for (var j = color_marks[i + 1] + (diff*10); j >= color_marks[i+1]; j--){
                height_map[j] = inches_val;
                inches_val += increment;
            }
        } else if (color_marks[i]){ // end of the list
            var diff = color_marks[i-1] - color_marks[i];
            var increment = 12 / diff;
            var inches_val = i * 12;
            // we extend upward to handle all trucks
            for (var j = color_marks[i]; j >= color_marks[i] - (diff*5); j--){
                height_map[j] = inches_val;
                inches_val += increment;
            }
        }
    }
    // console.log(height_map);
}

/*
getPhi takes a x pixel location on the image and converts it to a radian value
where 0 is directly in front of the driver as marked by the user

px_x: the x pixel location
*/
function getPhi(px_x){
    var diff = zero - neg_90; // px difference between the angle marks
    var degree_v = diff/90; // number of px each angle, 90 is diff angle size
    var past_zero = px_x - zero; // number of px off zero deg
    var deg = past_zero/degree_v;
    var radians = deg * (Math.PI / 180);
    return radians;
}

function getTanDeg(deg) {
    var rad = deg * Math.PI/180;
    return Math.tan(rad);
}

function getATanDeg(deg) {
    return Math.atan(deg) * (180/Math.PI);
} 

/*
Creates list of phis and nvps (ground intersection points) for both front and passenger views.
Starts chain of requests initiated in each requests onload which
end in the percentage visible area being displayed
*/
function calcGroundIntersection(){
    var ground_intersections_front = [];
    var ground_intersections_passenger = [];
    var phis_front = [];
    var phis_passenger = [];

    // make lists of phis and nvps for front and passenger
    for (var i = 0; i < bottom_view_front.length; i++){
        var bottom_view_inches = height_map[Math.round(bottom_view_front[i].y)];
        var opposite_side = driver_height - bottom_view_inches;
        var fov_angle = getATanDeg(opposite_side/marks_dist);
        var ground_intersection = driver_height * getTanDeg(90-fov_angle); 
        ground_intersections_front.push(ground_intersection); 

        var phi = getPhi(bottom_view_front[i].x);
        phis_front.push(phi);
    }

    for (var i = 0; i < bottom_view_passenger.length; i++){
        var bottom_view_inches = height_map[Math.round(bottom_view_passenger[i].y)];
        var opposite_side = driver_height - bottom_view_inches;
        var fov_angle = getATanDeg(opposite_side/marks_dist);
        var ground_intersection = driver_height * getTanDeg(90-fov_angle);
        ground_intersections_passenger.push(ground_intersection); 

        var phi = getPhi(bottom_view_passenger[i].x);
        phis_passenger.push(phi);
    }

    //remove any overlap in front and passenger window if it exists
    while(phis_front[phis_front.length-1] <= phis_passenger[0]){
        phis_front.pop()
        ground_intersections_front.pop()
    }
    calcBlindVolumeFront(ground_intersections_front, ground_intersections_passenger, phis_front, phis_passenger); 
}

/*
calcBlindVolumeFront makes a request to the getblindarea end point with the
front window information, onload it calls calcBlindVolumePassenger

ground_intersections_front: list(int), nearest visible points along the bottom of field of view from user drawn points along the front window
ground_intersections_passenger: list(int), nearest visible points along the bottom of field of view from user drawn points along the passenger window
phis_front: list(int), list of radians corresponding to ground_intersection_front
phis_passenger: list(int), list of radians corresponding to ground_intersection_passenger
*/
function calcBlindVolumeFront(ground_intersections_front, ground_intersections_passenger, phis_front, phis_passenger){
    let request = new XMLHttpRequest();
    let url = "/api/v1/getblindarea/";
    request.responseType = "json";
    var headers = {'content-type': 'application/json'};
    request.onload = function() {
        let response = this.response;
        console.log(response);
        blind_volume += response['data'];
        calcBlindVolumePassenger(ground_intersections_front, ground_intersections_passenger, phis_front, phis_passenger);
    }

    request.open("POST", url);
    request.send(body=JSON.stringify({'NVPs': ground_intersections_front, 'phis' : phis_front, 'DH' : driver_height, 'c' : c, 'd': d}));
}

/*
calcBlindVolumePassenger makes a request to the getblindarea end point with the
passenger window information, onload it calls calcBlindVolumeBetween

ground_intersections_front: list(int), nearest visible points along the bottom of field of view from user drawn points along the front window
ground_intersections_passenger: list(int), nearest visible points along the bottom of field of view from user drawn points along the passenger window
phis_front: list(int), list of radians corresponding to ground_intersection_front
phis_passenger: list(int), list of radians corresponding to ground_intersection_passenger
*/
function calcBlindVolumePassenger(ground_intersections_front, ground_intersections_passenger, phis_front, phis_passenger){
    let request = new XMLHttpRequest();
    let url = "/api/v1/getblindarea/";
    request.responseType = "json";
    var headers = {'content-type': 'application/json'};
    request.onload = function() {
        let response = this.response;
        console.log(response);
        blind_volume += response['data'];
        calcBlindVolumeBetween(phis_front, phis_passenger);
    }

    request.open("POST", url);
    request.send(body=JSON.stringify({'NVPs': ground_intersections_passenger, 'phis' : phis_passenger, 'DH' : driver_height, 'c' : c, 'd': d}));
}

/*
calcBlindVolumeBetween makes a request to the getinterestarea end point with the
phi on either side of the barrier between the front and passenger window information, onload it calls calcTotalVolume

phis_front: list(int), list of radians corresponding to ground_intersection_front
phis_passenger: list(int), list of radians corresponding to ground_intersection_passenger
*/
function calcBlindVolumeBetween(phis_front, phis_passenger){
    //bookend_phis is the phis which bookend the blind area between the front and passenger window 
    var bookend_phis = [phis_front[phis_front.length - 1], phis_passenger[0]];
    let request = new XMLHttpRequest();
    // getinterestarea is instead of getblindarea because want the entire slice
    // of area blocked
    let url = "/api/v1/getinterestarea/";
    request.responseType = "json";
    var headers = {'content-type': 'application/json'};
    request.onload = function() {
        let response = this.response;
        console.log(response);
        blind_volume += response['data'];
        var phis = phis_front.concat(phis_passenger);
        calcTotalVolume(phis);
    }

    request.open("POST", url);
    request.send(body=JSON.stringify({'phis': bookend_phis, 'c': c, 'd': d}), headers=headers);
}

/*
calcTotalVolume makes a request to the getinterestarea endpoint and onload calls postRatio()

phis: list(int), list of all phis from both windows
*/
function calcTotalVolume(phis){
    let request = new XMLHttpRequest();
    let url = "/api/v1/getinterestarea/";
    request.responseType = "json";
    var headers = {'content-type': 'application/json'};
    request.onload = function() {
        let response = this.response;
        console.log(response);
        total_volume = response['data'];
        postRatio();
    }

    request.open("POST", url);
    request.send(body=JSON.stringify({'phis': phis, 'c': c, 'd': d}), headers=headers);
}

/*
Calculates the precentage visible volume and displays it
*/
function postRatio(){
    console.log(total_volume);
    console.log(blind_volume);
    var ratio = (total_volume - blind_volume)/total_volume;
    var tperc = ratio * 100;
    var rounded_perc = Math.round(tperc, 0); // at this point we don't feel confident providing more percision
    percentage.innerHTML = "Percent of volume visible: " + rounded_perc + "%";
    console.log(ratio);
    perc = rounded_perc;
}

/*
If user enters vin, truckInfoFromVIN gets truck model info to store in the database
Uses the National Highway Traffic Saftey Administrations Product Informaton Catalog's API

vin: string, either a ful or partial vehicle vin
perc: int, the percentage visible area

*/
function truckInfoFromVIN(vin, perc){
    // var vin = "5PVNC6JK562S10283"; // example
    let request = new XMLHttpRequest();
    var uvin = vin.toUpperCase();
    let url = "https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVINValues/" + uvin + "?format=json";

    request.onload = function() {
      if (this.readyState === 4 && this.status === 200) {
        let response = JSON.parse(this.responseText);
        getElements(response);
      }
    }

    request.open("GET", url, true);
    request.send();
    
    getElements = function(response){
        console.log(response);
        var vmake = response["Results"]["0"]["Make"];
        var vmodel = response["Results"]["0"]["Model"];
        var vgvwr = response["Results"]["0"]["GVWR"];
        var partialvin = uvin.substring(0,10);
        var vwc = vgvwr.substring(0,7);
        let request = new XMLHttpRequest();
        let url = "/api/v1/addtruck/";
        request.responseType = "json";
        var headers = {'content-type': 'application/json'};
        request.onload = function() {
            let response = this.response;
            console.log(response);
        }

        request.open("POST", url);
        request.send(body=JSON.stringify({'vin': uvin, 'partialvin': partialvin, 'vmake': vmake, 'vmodel': vmodel, 'vwc': vwc, 'perc': perc}), headers=headers);
    }  
}

</script>

{% endblock %}
